import os
import subprocess
import gmsh
import json
from collections import deque
from mesh_processors import mesh_processing as mp
from mesh_processors import modify_inp as mi
#from ccx_inp import ccx_inp as ccx
#from cgx_frd import cgx_frd as cf

inpath = "Thingi10K/selected/"
outpath = "Thingi10K/selected/"
ERRORS = {}

def get_files(inpath, method = "directory", json_name = ""):
    if method == "directory":
        files = os.listdir(inpath)
        # delete files that do not end with ".stl"
        for file in files:
            if not file.endswith(".stl"):
                files.remove(file)
        return files
    elif method == "json":
        with open(inpath + json_name, "r") as file:
            files_list = json.load(file)
        files = []
        for key in files_list.keys():
            files.append(key)
        return files
    elif method == "custom":
        files = []
        return files
    
def write_to_log(stl_file, log_file, message):
    with open(log_file, "a") as log:
        log.write(f"{stl_file} results:\n")
        log.write(message)

def mp_subprocess(file, inpath, outpath, ERROR):
    try:
        result = subprocess.run(
            ["python3", "-c", f"import mesh_processors; mesh_processors.mesh_processing('{file}', '{inpath}', '{outpath}')"],
            capture_output = True
            )
        output = result.stdout.decode("utf-8")
        print("finished mp subprocess")
        if result.returncode == 0:
            print("finished\n")
            return True
        else:
            print("Error\n")
            raise subprocess.CalledProcessError(result.returncode, result.args)
    except subprocess.CalledProcessError as e:
        print("exception\n")
        message = f'Error processingsss {file}: {e}\n\n'
        ERROR[file] = message
        write_to_log(file, outpath + "log_job.txt", message)
        return None

###################################################
###################################################
files = get_files(inpath, method = "directory", json_name = "list_success.json")

'''
for file in files:
    file_path = inpath + file
    with open("trials.txt", "w") as log:
        log.write(f"Started file {file}.\n")
    message = ""
    try:
        # Process mesh with gmsh
        inp_file_path = mp(file, inpath, outpath)
        ## If mp encounters an error, jump to the except block
        # modify the .inp file generated by mp
        mi(inp_file_path)
        inp_file_path = inp_file_path.replace(".inp", "")
        command = "ccx " + inp_file_path
        
        #message = run_and_capture_tail(command)
        
        with open(outpath + "_ccx_output.txt", "w") as outfile:
            # Run Calculix with the modified .inp file
            subprocess.run(f"{command} | tail -n 6", shell=True, stdout=outfile, stderr=outfile)        
            #run_with_timeout(command, outfile)

        with open(outpath + "_ccx_output.txt", "r") as outfile:
            # if the sixth from the last line of the output file does not contain "Job finished", write an error message to the error log
            output_lines = outfile.readlines()
            if not "Job finished" in output_lines[-6]:
                ERRORS[file] = output_lines
                message = "".join(output_lines)
            else:
                message = "Calculix analysis completed successfully.\n\n"
        
        write_to_log(file, outpath + "log_job.txt", message)

    except Exception as e:
        ERRORS[file] = str(e)
        write_to_log(file, outpath + "log_job.txt", str(e)+"\n\n")
        continue

'''

for file in files:
    with open("trials.txt", "w") as log:
        log.write(f"Started file {file}.\n")
    message = ""
    result = mp_subprocess(file, inpath, outpath, ERRORS)
    if result:
        inp_file_path = outpath + file
        inp_file_path = inp_file_path.replace(".stl", ".inp")
        mi(inp_file_path)
        inp_file_path = inp_file_path.replace(".inp", "")

        command = "ccx " + inp_file_path

        with open(outpath + "_ccx_output.txt", "w") as outfile:
            subprocess.run(f"{command} | tail -n 6", shell=True, stdout=outfile, stderr=outfile)
        
        with open(outpath + "_ccx_output.txt", "r") as outfile:
            output_lines = outfile.readlines()
            if not "Job finished" in output_lines[-6]:
                ERRORS[file] = output_lines
                message = "".join(output_lines)
            else:
                message = "Calculix analysis completed successfully.\n\n"
        
        write_to_log(file, outpath + "log_job.txt", message)

# Export ERRORS to a json file
with open(outpath + "list_error.json", "w") as list_error:
    json.dump(ERRORS, list_error)