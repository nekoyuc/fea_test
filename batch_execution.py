import os
import subprocess
import gmsh
import json
from collections import deque
from mesh_processors import mesh_processing as mp
from mesh_processors import modify_inp as mi
import subprocess
import time
#from ccx_inp import ccx_inp as ccx
#from cgx_frd import cgx_frd as cf

def get_files(path, method = "directory", json_name = ""):
    if method == "directory":
        files = os.listdir(path)
        # delete files that do not end with ".stl"
        for file in files:
            if not file.endswith(".stl"):
                files.remove(file)
        return files
    elif method == "json":
        with open(path + json_name, "r") as file:
            files_list = json.load(file)
        files = []
        for key in files_list.keys():
            files.append(key)
        return files
    elif method == "custom":
        files = []
        return files
    
def write_to_log(stl_file, log_file, count, message):
    with open(log_file, "a") as log:
        log.write(f"Count {count}, {stl_file} results:\n")
        log.write(message)

def mp_subprocess(file, inpath, outpath, ERROR):
    try:
        result = subprocess.run(
            ["python3", "-c", f"import mesh_processors; mesh_processors.mesh_processing('{file}', '{inpath}', '{outpath}')"],
            capture_output=True,
            timeout=400  # Set the timeout value in seconds
        )
        output = result.stdout
        print(str(file) + " finished mp subprocess")
        if result.returncode == 0:
            print("finished\n")
            return True
        else:
            print("Error\n")
            # Take the last 6 lines of output
            output_lines = output.splitlines()
            output_lines = output_lines[-6:]
            message = "Error\n" + f'Error processing {file}: {output_lines}\n\n'
            ERROR[file] = message
            write_to_log(file, outpath + "log_job.txt", count, message)
            raise subprocess.CalledProcessError(result.returncode, result.args)
    except subprocess.TimeoutExpired:
        print("Timeout\n")
        message = "Timeout\n" + f'Timeout processing {file}\n\n'
        ERROR[file] = message
        write_to_log(file, outpath + "log_job.txt", count, message)
        return None
    except subprocess.CalledProcessError as e:
        print("exception\n")
        message = "Exception\n" + f'Error processing {file}: {e}\n\n'
        ERROR[file] = message
        write_to_log(file, outpath + "log_job.txt", count, message)
        return None

###################################################
###################################################
inpath = "Thingi10K/raw_meshes/Batch7/"
outpath = "Thingi10K/raw_meshes/Batch7_results/"
ERRORS = {}
files = get_files(inpath, method = "directory", json_name = "list_success.json")

count = 1

'''

for file in files:
    if file in ["1717685.stl", "1717686.stl", "1706478.stl"]:
        write_to_log(file, outpath + "log_job.txt", count, "Skipped\n\n")
        count = count + 1
        continue
    file_path = inpath + file
    with open("trials.txt", "w") as log:
        log.write(f"Started file {file}.\n")
    message = ""
    try:
        # Process mesh with gmsh
        inp_file_path = mp(file, inpath, outpath)
        ## If mp encounters an error, jump to the except block
        # modify the .inp file generated by mp
        mi(inp_file_path)
        inp_file_path = inp_file_path.replace(".inp", "")
        command = "ccx " + inp_file_path
        
        with open(outpath + "_ccx_output.txt", "w") as outfile:
            # Run Calculix with the modified .inp file
            subprocess.run(f"{command} | tail -n 6", shell=True, stdout=outfile, stderr=outfile)        

        with open(outpath + "_ccx_output.txt", "r") as outfile:
            # if the sixth from the last line of the output file does not contain "Job finished", write an error message to the error log
            output_lines = outfile.readlines()
            if not "Job finished" in output_lines[-6]:
                ERRORS[file] = output_lines
                message = "".join(output_lines)
            else:
                message = "Calculix analysis completed successfully.\n\n"
        
        write_to_log(file, outpath + "log_job.txt", count, message)
        count = count + 1

    except Exception as e:
        ERRORS[file] = str(e)
        write_to_log(file, outpath + "log_job.txt", count, str(e)+"\n\n")
        count = count + 1
        continue
    

'''

for file in files:
    with open("trials.txt", "w") as log:
        log.write(f"Started file {file}.\n")
    message = ""
    result = mp_subprocess(file, inpath, outpath, ERRORS)
    if result:
        inp_file_path = outpath + file
        inp_file_path = inp_file_path.replace(".stl", ".inp")
        mi(inp_file_path)
        inp_file_path = inp_file_path.replace(".inp", "")

        command = "ccx " + inp_file_path

        with open(outpath + "_ccx_output.txt", "w") as outfile:
            subprocess.run(f"{command} | tail -n 6", shell=True, stdout=outfile, stderr=outfile)
        
        with open(outpath + "_ccx_output.txt", "r") as outfile:
            output_lines = outfile.readlines()
            if not "Job finished" in output_lines[-6]:
                ERRORS[file] = output_lines
                message = "Calculix\n" + "".join(output_lines)
            else:
                message = "Calculix analysis completed successfully.\n\n"
        
        write_to_log(file, outpath + "log_job.txt", count, message)
    count = count + 1


# Export ERRORS to a json file
with open(outpath + "list_error.json", "w") as list_error:
    json.dump(ERRORS, list_error)